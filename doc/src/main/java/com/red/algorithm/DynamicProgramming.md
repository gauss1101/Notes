# 动态规划算法

## 基本概念

动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。

动态规划算法的基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。

## 基本思想

由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个数组中。

## 求解步骤

**第一步骤**：定义**数组元素的含义**。前面提到，我们会用一个数组，来保存历史记录，假设用一维数组 dp[] 。这时候你必须问自己，这个数组每个元素的含义是什么？

**第二步骤**：找出**数组元素之间的关系式**。动态规划，类似于高中学的**数学归纳法**的，当我们要计算 dp[n] 时，是可以利用 dp[n-1]，dp[n-2]…..dp[1]，来推出 dp[n] 的，也就是可以利用**历史数据**来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，这个就是他们的关系式了。而这一步，也是最难的一步，后面会讲几种类型的题来说。

**第三步骤**：找出**初始值**。虽然我们知道了数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，我们可以通过 dp[n-1] 和 dp[n-2] 来计算 dp[n]，但是，我们得知道初始值。例如一直推下去的话，会有 dp[3] = dp[2] + dp[1]。而 dp[2] 和 dp[1] 是不能再分解的了，所以我们必须要能够直接获得 dp[2] 和 dp[1] 的值，而这，就是**所谓的初始值**。

由了**初始值**，并且有了**数组元素之间的关系式**，那么我们就可以得到 dp[n] 的值了，而 dp[n] 的含义是由你来定义的，你想**求什么，就定义它是什么**，这样，这道题也就解出来了。

## 例题讲解

### 一维数组

https://cloud.tencent.com/developer/article/1538177

### 二维数组

## 练习

> 练习题来源leetcode
>
> https://leetcode-cn.com/problemset/all/?topicSlugs=dynamic-programming

### 简单

| 题号 | 题名       |
| ---- | ---------- |
| 53   | 最大子序和 |
| 70   | 爬楼梯     |



### 中等

| 题号 | 题名           |
| ---- | -------------- |
| 5    | 最长回文子串   |
| 62   | 不 同路径      |
| 64   | 最小路径和     |
| 264  | 丑数II         |
| 322  | 零钱兑换       |
| 516  | 最长回文子序列 |



### 困难

| 题号 | 题名           |
| ---- | -------------- |
| 403  | 青蛙过河       |
| 466  | 统计重复个数   |
| 1092 | 最短公共超序列 |

